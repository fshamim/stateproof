package io.stateproof.sync

import io.stateproof.testgen.SimpleTestCase

/**
 * Configuration for test code generation.
 */
data class TestCodeGenConfig(
    /** Package name for generated tests */
    val packageName: String,
    /** Class name for the test class */
    val testClassName: String,
    /** State machine factory function call (e.g., "createStateMachine()") */
    val stateMachineFactory: String = "createStateMachine()",
    /** Event class prefix (e.g., "Events") */
    val eventClassPrefix: String = "Events",
    /** Whether to include runBlocking wrapper */
    val useRunBlocking: Boolean = true,
    /** Whether to include runTest wrapper (for coroutines test) */
    val useRunTest: Boolean = false,
    /** Custom imports to add */
    val additionalImports: List<String> = emptyList(),
    /** Indent string */
    val indent: String = "    ",
    /** Class-level annotations (e.g., "@RunWith(AndroidJUnit4::class)") */
    val classAnnotations: List<String> = emptyList(),
)

/**
 * Generates Kotlin test code for StateProof tests.
 */
object TestCodeGenerator {

    /**
     * Generates a complete test file with all tests.
     */
    fun generateTestFile(
        config: TestCodeGenConfig,
        tests: List<SimpleTestCase>,
        timestamp: String,
    ): String = buildString {
        // Package
        appendLine("package ${config.packageName}")
        appendLine()

        // Imports
        appendLine("import io.stateproof.sync.StateProofGenerated")
        appendLine("import io.stateproof.sync.StateProofObsolete")
        if (config.useRunBlocking) {
            appendLine("import kotlinx.coroutines.runBlocking")
        }
        if (config.useRunTest) {
            appendLine("import kotlinx.coroutines.test.runTest")
        }
        appendLine("import kotlin.test.Ignore")
        appendLine("import kotlin.test.Test")
        appendLine("import kotlin.test.assertEquals")
        for (import in config.additionalImports) {
            appendLine("import $import")
        }
        appendLine()

        // Class
        appendLine("/**")
        appendLine(" * Generated by StateProof - Do not edit manually.")
        appendLine(" * ")
        appendLine(" * Generated at: $timestamp")
        appendLine(" * Total tests: ${tests.size}")
        appendLine(" */")
        for (annotation in config.classAnnotations) {
            appendLine(annotation)
        }
        appendLine("class ${config.testClassName} {")
        appendLine()

        // Tests
        for (test in tests) {
            append(generateSingleTest(config, test, timestamp))
            appendLine()
        }

        appendLine("}")
    }

    /**
     * Generates a single test function.
     */
    fun generateSingleTest(
        config: TestCodeGenConfig,
        testCase: SimpleTestCase,
        timestamp: String,
    ): String = buildString {
        val indent = config.indent
        val hash = extractHash(testCase.name)

        // Annotation
        appendLine("${indent}@StateProofGenerated(")
        appendLine("${indent}${indent}pathHash = \"$hash\",")
        appendLine("${indent}${indent}generatedAt = \"$timestamp\",")
        appendLine("${indent}${indent}schemaVersion = 1,")
        appendLine("${indent})")
        appendLine("${indent}@Test")

        // Function signature
        val wrapper = when {
            config.useRunTest -> "runTest"
            config.useRunBlocking -> "runBlocking"
            else -> null
        }

        if (wrapper != null) {
            appendLine("${indent}fun `${testCase.name}`() = $wrapper {")
        } else {
            appendLine("${indent}fun `${testCase.name}`() {")
        }

        // Path comment
        appendLine("${indent}${indent}//${testCase.path.joinToString("_")}")
        appendLine()

        // STATEPROOF:EXPECTED marker
        appendLine("${indent}${indent}${StateProofMarkers.BEGIN_EXPECTED}")

        // Expected transitions
        appendLine("${indent}${indent}val expectedTransitions = listOf(")
        for (transition in testCase.expectedTransitions) {
            appendLine("${indent}${indent}${indent}\"$transition\",")
        }
        appendLine("${indent}${indent})")

        // STATEPROOF:END marker
        appendLine("${indent}${indent}${StateProofMarkers.END}")
        appendLine()

        // User implementation section separator
        appendLine("${indent}${indent}${StateProofMarkers.USER_SECTION}")
        appendLine("${indent}${indent}${StateProofMarkers.USER_HEADER}")
        appendLine("${indent}${indent}${StateProofMarkers.USER_SECTION}")
        appendLine()

        // Default implementation (commented out - user must implement)
        appendLine("${indent}${indent}// TODO: Implement test - create state machine and fire events")
        appendLine("${indent}${indent}// val sm = ${config.stateMachineFactory}")
        for (event in testCase.eventSequence) {
            appendLine("${indent}${indent}// sm.onEvent(${config.eventClassPrefix}.$event)")
        }
        appendLine("${indent}${indent}// sm.awaitIdle()")
        appendLine()
        appendLine("${indent}${indent}// assertEquals(expectedTransitions, sm.getTransitionLog())")

        // Close function
        appendLine("${indent}}")
    }

    /**
     * Updates an existing test with new expected transitions while preserving user code.
     */
    fun updateExistingTest(
        existingTest: TestFileParser.ParsedTest,
        newTransitions: List<String>,
        timestamp: String,
        indent: String = "    ",
    ): String {
        val original = existingTest.fullText

        // Find and replace the section between markers
        val beginMatch = StateProofMarkers.BEGIN_PATTERN.find(original)
        val endMatch = StateProofMarkers.END_PATTERN.find(original)

        if (beginMatch == null || endMatch == null) {
            // No markers found - can't update safely
            return original
        }

        // Build new generated section
        val newGeneratedSection = buildString {
            appendLine()
            appendLine("${indent}${indent}val expectedTransitions = listOf(")
            for (transition in newTransitions) {
                appendLine("${indent}${indent}${indent}\"$transition\",")
            }
            appendLine("${indent}${indent})")
            append("${indent}${indent}")
        }

        // Replace section between markers
        val before = original.substring(0, beginMatch.range.last + 1)
        val after = original.substring(endMatch.range.first)

        // Update annotation timestamp
        val updatedBefore = updateAnnotationTimestamp(before, timestamp)

        return updatedBefore + newGeneratedSection + after
    }

    /**
     * Marks a test as obsolete.
     */
    fun markTestObsolete(
        existingTest: TestFileParser.ParsedTest,
        reason: String,
        timestamp: String,
        indent: String = "    ",
    ): String {
        val original = existingTest.fullText

        // Check if already marked obsolete
        if (existingTest.isObsolete) {
            return original
        }

        // Find where to insert the obsolete annotation (before @StateProofGenerated or @Test)
        val insertPoint = when {
            original.contains("@StateProofGenerated") -> {
                original.indexOf("@StateProofGenerated")
            }
            original.contains("@Test") -> {
                original.indexOf("@Test")
            }
            else -> 0
        }

        val obsoleteAnnotation = buildString {
            appendLine("${indent}@StateProofObsolete(")
            appendLine("${indent}${indent}reason = \"$reason\",")
            appendLine("${indent}${indent}markedAt = \"$timestamp\",")
            appendLine("${indent}${indent}originalPath = \"${existingTest.expectedTransitions.joinToString(" -> ")}\",")
            appendLine("${indent})")
            appendLine("${indent}@Ignore(\"StateProof: Path obsolete since $timestamp - review and delete manually\")")
        }

        return original.substring(0, insertPoint) +
                obsoleteAnnotation +
                original.substring(insertPoint)
    }

    /**
     * Updates the generatedAt timestamp in the annotation.
     */
    private fun updateAnnotationTimestamp(text: String, newTimestamp: String): String {
        val pattern = Regex("""generatedAt\s*=\s*"[^"]+"""")
        return pattern.replace(text, """generatedAt = "$newTimestamp"""")
    }

    /**
     * Extracts the hash from a generated test name.
     */
    private fun extractHash(testName: String): String {
        val parts = testName.split("_")
        return if (parts.size >= 3) parts[2] else testName
    }
}
